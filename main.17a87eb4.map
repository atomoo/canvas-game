{"version":3,"sources":["js/utils/utils.js","js/shape/point.js","js/vector/vector.js","js/shape/polygon.js","js/obj/obstacle.js","js/constant/constant.js","js/game/game.js","js/obj/player.js","js/main.js"],"names":["log","console","bind","random","a","b","Math","floor","Point","x","y","Vector","point","undefined","sqrt","vector","v","subtract","m","getMagnitude","p","perpendicular","normalize","Polygon","points","length","Error","len","axes","vNext","index","pNext","push","edge","normal","axis","projections","getAllprojectionOnAxis","protechtionRange","forEach","min","max","dotProduct","polygon","projectionRange","getprojectionRangeOnAxis","targetProjectionRange","getAxes","concat","isCollideOnAxes","Obstacle","game","attribute","width","height","speedX","canvas","isInGame","context","c","save","beginPath","moveTo","lineTo","closePath","stroke","restore","GAME_STATUS","PLAYER_STATUS","Game","selector","document","querySelector","getContext","actions","obstacles","score","addEventListener","e","code","cb","callback","player","obstacle","isDead","start","status","RUNNING","run","lastObstacle","range","addObstacle","id","window","requestAnimationFrame","generateObstacle","update","render","DEAD","cancelAnimationFrame","i","o","isCollideWithObstacle","over","PAUSE","continueGame","pause","splice","font","fillText","clearRect","textBaseline","textAlign","renderScore","renderGameOver","renderObstacles","Player","positionY","angle","speedY","speedAngle","PI","maxY","speedVelocity","SLIDING","registerAction","jump","getPolygon","isCollideWithOther","isJumping","JUMPING","moveY","rotate","isCollideWithLine","revertSpeed","translate","strokeRect","main","addPlayer","restart"],"mappings":"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","file":"main.17a87eb4.map","sourceRoot":"..","sourcesContent":["\nexport const log = console.log.bind(console)\nexport const random = function random(a, b) {\n    return a + Math.floor(Math.random() * (b - a + 1))\n}\n","export default class Point {\n    constructor(x, y) {\n        this.x = x\n        this.y = y\n    }\n}\n","export default class Vector {\n    constructor(point) {\n        if (point === undefined) {\n            this.x = 0\n            this.y = 0\n        }\n        else {\n            this.x = point.x\n            this.y = point.y\n        }\n    }\n\n    getMagnitude() {\n        return Math.sqrt(this.x ** 2 + this.y ** 2)\n    }\n\n    add(vector) {\n        const v = new Vector()\n        v.x = this.x + vector.x\n        v.y = this.y + vector.y\n        return v\n    }\n\n    subtract(vector) {\n        const v = new Vector()\n        v.x = this.x - vector.x\n        v.y = this.y - vector.y\n        return v\n    }\n\n    dotProduct(vector) {\n        return this.x * vector.x + this.y * vector.y\n    }\n\n    // 由两点生成边\n    edge(vector) {\n        return this.subtract(vector)\n    }\n\n    // 垂直，即投影轴\n    perpendicular() {\n        const v = new Vector()\n        v.x = this.y\n        v.y = 0 - this.x\n        return v\n    }\n\n    normalize() {\n        const v = new Vector(0, 0)\n        const m = this.getMagnitude()\n        if (m !== 0) {\n            v.x = this.x / m\n            v.y = this.y / m\n        }\n        return v\n    }\n\n    // 投影轴的单位向量\n    normal() {\n        const p = this.perpendicular()\n        return p.normalize()\n    }\n}\n","import Vector from '../vector/vector'\n\nexport default class Polygon {\n    constructor(points) {\n        if (points.length <= 0) {\n            throw new Error('need points')\n        }\n        this.points = points\n    }\n\n    /**\n     * get all perpendicular axes from each line\n     */\n    getAxes() {\n        const len = this.points.length\n        if (len <= 0) {\n            throw new Error('need points')\n        }\n        const axes = []\n        const v = new Vector()\n        const vNext = new Vector()\n        for (let index = 0; index < len - 1; index++) {\n            const p = this.points[index]\n            v.x = p.x\n            v.y = p.y\n            const pNext = this.points[index + 1]\n            vNext.x = pNext.x\n            vNext.y = pNext.y\n            axes.push(v.edge(vNext).normal())\n        }\n        v.x = this.points[len - 1].x\n        v.y = this.points[len - 1].y\n        vNext.x = this.points[0].x\n        vNext.y = this.points[0].y\n        axes.push(v.edge(vNext).normal())\n        return axes\n    }\n\n    getprojectionRangeOnAxis(axis) {\n        const projections = this.getAllprojectionOnAxis(axis)\n        if (projections.length > 0) {\n            const protechtionRange = {\n                max: projections[0],\n                min: projections[0]\n            }\n            projections.forEach((p) => {\n                if (p < protechtionRange.min) {\n                    protechtionRange.min = p\n                }\n                if (p > protechtionRange.max) {\n                    protechtionRange.max = p\n                }\n            })\n            return protechtionRange\n        }\n        return null\n    }\n\n    getAllprojectionOnAxis(axis) {\n        const projections = []\n        this.points.forEach((p) => {\n            projections.push(new Vector(p).dotProduct(axis))\n        })\n        return projections\n    }\n\n    isCollideOnAxes(axes, polygon) {\n        for (let index = 0; index < axes.length; index++) {\n            const axis = axes[index]\n            const projectionRange = this.getprojectionRangeOnAxis(axis)\n            const targetProjectionRange = polygon.getprojectionRangeOnAxis(axis)\n            if (projectionRange.max < targetProjectionRange.min\n                || projectionRange.min > targetProjectionRange.max) {\n                return false\n            }\n        }\n        return true\n    }\n\n    isCollideWithOther(polygon) {\n        const axes = this.getAxes().concat(polygon.getAxes())\n        return this.isCollideOnAxes(axes, polygon)\n    }\n}\n","import Point from '../shape/point'\nimport Polygon from '../shape/polygon'\n\nexport default class Obstacle {\n    constructor(game, attribute) {\n        this.game = game\n        this.x = attribute.x\n        this.y = attribute.y\n        this.width = attribute.width\n        this.height = attribute.height\n        this.speedX = 2\n    }\n\n    isDead() {\n        return this.x < 0\n    }\n\n    isInGame() {\n        return this.x > 0 && this.x < this.game.canvas.width\n    }\n\n    update() {\n        this.x -= this.speedX\n    }\n\n    getPolygon() {\n        return new Polygon([\n            new Point(this.x, this.y),\n            new Point(this.x + this.width, this.y),\n            new Point(this.x + this.width / 2, this.y - this.height)\n        ])\n    }\n\n    render() {\n        if (this.isInGame()) {\n            const { context: c } = this.game\n            c.save()\n            c.beginPath()\n            c.moveTo(this.x, this.y)\n            c.lineTo(this.x + this.width, this.y)\n            c.lineTo(this.x + this.width / 2, this.y - this.height)\n            c.closePath()\n            c.stroke()\n            c.restore()\n        }\n    }\n}\n","export const GAME_STATUS = {\n    RUNNING: 'running',\n    PAUSE: 'pause',\n    DEAD: 'dead'\n}\nexport const PLAYER_STATUS = {\n    JUMPING: 'jumping',\n    SLIDING: 'sliding'\n}\n","import { log, random } from '../utils/utils'\nimport Obstacle from '../obj/obstacle'\nimport { GAME_STATUS } from '../constant/constant'\n\nexport default class Game {\n    constructor(selector) {\n        this.canvas = document.querySelector(selector)\n        this.context = this.canvas.getContext('2d')\n        this.actions = []\n        this.obstacles = []\n        this.score = 0\n        document.addEventListener('keydown', (e) => {\n            if (this.actions[e.code]) {\n                this.actions[e.code].forEach((cb) => {\n                    cb()\n                })\n            }\n        })\n    }\n\n    registerAction(code, callback) {\n        if (this.actions[code]) {\n            this.actions[code].push(callback)\n        }\n        else {\n            this.actions[code] = [callback]\n        }\n    }\n\n    addPlayer(player) {\n        this.player = player\n    }\n\n    addObstacle(obstacle) {\n        if (!obstacle.isDead()) {\n            this.obstacles.push(obstacle)\n        }\n    }\n\n    restart() {\n        this.score = 0\n        this.obstacles = []\n        this.start()\n    }\n\n    start() {\n        this.status = GAME_STATUS.RUNNING\n        this.run()\n    }\n\n    generateObstacle() {\n        const { obstacles } = this\n        const obstacle = new Obstacle(this, {\n            x: this.canvas.width,\n            y: 450,\n            width: 15,\n            height: 20\n        })\n        if (obstacles.length > 0) {\n            const lastObstacle = obstacles[obstacles.length - 1]\n            const range = random(60, 300)\n            obstacle.x = lastObstacle.x + range\n            this.addObstacle(obstacle)\n        }\n        else {\n            this.addObstacle(obstacle)\n        }\n    }\n\n    run() {\n        this.id = window.requestAnimationFrame(() => this.run())\n        log('running')\n        if (this.status === GAME_STATUS.RUNNING) {\n            this.generateObstacle()\n            this.update()\n            this.render()\n        }\n        else if (this.status === GAME_STATUS.DEAD) {\n            window.cancelAnimationFrame(this.id)\n        }\n    }\n    update() {\n        const { obstacles, player: p } = this\n        p.update()\n        for (let i = 0; i < obstacles.length; i++) {\n            obstacles[i].update()\n        }\n        const o = obstacles[0]\n        if (p.x + Math.sqrt(p.width ** 2 + p.height ** 2) >= o.x && p.isCollideWithObstacle(o)) {\n            this.over()\n        }\n        else {\n            this.score += 1\n        }\n    }\n\n    over() {\n        this.status = GAME_STATUS.DEAD\n    }\n\n    toggle() {\n        if (this.status === GAME_STATUS.PAUSE) {\n            this.continueGame()\n        }\n        else if (this.status === GAME_STATUS.RUNNING) {\n            this.pause()\n        }\n    }\n\n    pause() {\n        this.status = GAME_STATUS.PAUSE\n    }\n\n    continueGame() {\n        this.status = GAME_STATUS.RUNNING\n    }\n\n    renderObstacles() {\n        for (let i = 0; i < this.obstacles.length; i++) {\n            const o = this.obstacles[i]\n            if (o.isDead()) {\n                this.obstacles.splice(i, 1)\n                i -= 1\n            }\n            else {\n                o.render()\n            }\n        }\n    }\n\n    renderScore() {\n        const { context: c } = this\n        c.font = '24px serif'\n        c.fillText(`distance: ${this.score}`, 600, 50)\n    }\n\n    renderGameOver() {\n        const { context: c } = this\n        c.font = '30px serif'\n        c.fillText('Game Over ! ', this.canvas.width / 2, this.canvas.height / 2)\n    }\n\n    render() {\n        const { canvas, context } = this\n        context.clearRect(0, 0, canvas.width, canvas.height)\n        context.textBaseline = 'middle'\n        context.textAlign = 'center'\n        this.renderScore()\n        if (this.status === GAME_STATUS.DEAD) {\n            this.renderGameOver()\n        }\n        context.beginPath()\n        context.moveTo(0, 450)\n        context.lineTo(canvas.width, 450)\n        context.stroke()\n        this.player.render()\n        this.renderObstacles()\n    }\n}\n","import { PLAYER_STATUS, GAME_STATUS } from '../constant/constant'\nimport Point from '../shape/point'\nimport Polygon from '../shape/polygon'\n\nexport default class Player {\n    constructor(game, attribute) {\n        this.x = attribute.x\n        this.y = attribute.y\n        this.positionY = attribute.y\n        this.width = attribute.width\n        this.height = attribute.height\n        this.angle = 0\n        this.speedY = 0\n        this.speedAngle = 15 * Math.PI / 180\n        this.game = game\n        this.maxY = this.positionY - 100\n        this.speedVelocity = 1\n        this.status = PLAYER_STATUS.SLIDING\n        game.registerAction('Space', () => {\n            if (this.game.status === GAME_STATUS.RUNNING) {\n                this.jump()\n            }\n        })\n    }\n\n    isCollideWithLine() {\n        return this.y > this.positionY\n    }\n\n    isCollideWithMaxHeight() {\n        return this.y <= this.maxY\n    }\n\n    isCollideWithObstacle(obstacle) {\n        // TODO: 碰撞\n        return this.getPolygon().isCollideWithOther(obstacle.getPolygon())\n    }\n\n    getPolygon() {\n        return new Polygon([\n            new Point(this.x, this.y),\n            new Point(this.x, this.y + this.height),\n            new Point(this.x + this.width, this.y + this.height),\n            new Point(this.x + this.width, this.y)\n        ])\n    }\n\n    jump() {\n        // 跳跃\n        if (!this.isJumping()) {\n            this.status = PLAYER_STATUS.JUMPING\n            this.speedY = -15\n        }\n    }\n\n    isJumping() {\n        return this.status === PLAYER_STATUS.JUMPING\n    }\n\n    revertSpeed() {\n        this.y = this.positionY\n        this.angle = 0\n        this.status = PLAYER_STATUS.SLIDING\n    }\n\n    update() {\n        if (this.status === PLAYER_STATUS.JUMPING) {\n            this.moveY()\n            this.rotate()\n            if (this.isCollideWithLine()) {\n                this.revertSpeed()\n            }\n        }\n    }\n\n    moveY() {\n        const p = this\n        p.y += p.speedY\n        p.speedY += p.speedVelocity\n        if (p.isCollideWithLine()) {\n            p.speedY *= -1\n        }\n    }\n\n    rotate() {\n        this.angle += this.speedAngle\n    }\n\n    render() {\n        const { context: c } = this.game\n        c.save()\n        c.translate(this.x + this.width / 2, this.y + this.height / 2)\n        c.rotate(this.angle)\n        c.strokeRect(\n            this.width / -2,\n            this.height / -2,\n            this.width,\n            this.height\n        )\n        c.restore()\n    }\n}\n","import Game from './game/game'\nimport Player from './obj/player'\nimport { GAME_STATUS } from './constant/constant'\n\nfunction main() {\n    const game = new Game('#canvas')\n    const player = new Player(game, {\n        x: 100,\n        y: 429,\n        width: 20,\n        height: 20\n    })\n    game.addPlayer(player)\n    game.registerAction('Space', () => {\n        if (game.status === GAME_STATUS.DEAD) {\n            game.addPlayer(player)\n            game.restart()\n        }\n    })\n    game.start()\n}\n\nmain()\n"]}